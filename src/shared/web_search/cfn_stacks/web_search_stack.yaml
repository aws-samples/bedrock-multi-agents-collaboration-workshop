AWSTemplateFormatVersion: 2010-09-09
Description: This CloudFormation template deploy Web Search functionality using AWS Lambda Function
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Web Search API keys
        Parameters:
          - SerperApiKey
          - TavilyApiKey

Parameters:
  SerperApiKey:
    Type: String
    NoEcho: true
    Description: Provide SerperApiKey API Key to utilize /google_search path
  
  TavilyApiKey:
    Type: String
    NoEcho: true
    Description: Provide TavilyApiKey API Key to utilize /web_search or /travily_ai_search path

Conditions:
  HasSerperApiKey: !Not [!Equals [!Ref SerperApiKey, '']]
  HasTavilyApiKey: !Not [!Equals [!Ref TavilyApiKey, '']]

Resources:
  #####################
  ##### API Keys #####
  ###################

  SerperApiKeySecret:
    Type: 'AWS::SecretsManager::Secret'
    Condition: HasSerperApiKey
    Properties:
      Name: 'SERPER_API_KEY'
      Description: 'API Key for Serper service'
      SecretString: !Ref SerperApiKey

  TavilyApiKeySecret:
    Type: 'AWS::SecretsManager::Secret'
    Condition: HasTavilyApiKey
    Properties:
      Name: 'TAVILY_API_KEY'
      Description: 'API Key for Tavily service'
      SecretString: !Ref TavilyApiKey

  ########################
  ##### WebSearch #####
  ######################

  AgentLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.12
      FunctionName: websearch_lambda
      Handler: index.lambda_handler
      Role: !GetAtt AgentLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          LOG_LEVEL: "DEBUG"
          ACTION_GROUP: "WebSearchActionGroup"
      Code:
        ZipFile: !Sub |
          # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
          # SPDX-License-Identifier: MIT-0
          import http.client
          import json
          import logging
          import os
          import urllib.parse
          import urllib.request

          import boto3

          log_level = os.environ.get("LOG_LEVEL", "INFO").strip().upper()
          logging.basicConfig(format="[%(asctime)s] p%(process)s {%(filename)s:%(lineno)d} %(levelname)s - %(message)s")
          logger = logging.getLogger(__name__)
          logger.setLevel(log_level)

          def is_env_var_set(env_var: str) -> bool:
              return env_var in os.environ and os.environ[env_var] not in ("", "0", "false", "False")


          def get_from_secretstore_or_env(key: str) -> str:
              if is_env_var_set(key):
                  logger.warning(f"getting value for {key} from environment var; recommended to use AWS Secrets Manager instead")
                  return os.environ[key]

              session = boto3.session.Session()
              secrets_manager = session.client(service_name="secretsmanager")#, region_name=AWS_REGION)
              try:
                  secret_value = secrets_manager.get_secret_value(SecretId=key)
              except Exception as e:
                  logger.error(f"could not get secret {key} from secrets manager: {e}")
                  raise e

              secret: str = secret_value["SecretString"]

              return secret

          FUNCTION_NAMES = ["tavily_ai_search", "google_search", "web_search"]

          try:
            SERPER_API_KEY = get_from_secretstore_or_env("SERPER_API_KEY")
            FUNCTION_NAMES.append("google_search")
          except Exception as e:
            SERPER_API_KEY = None

          try:
            TAVILY_API_KEY = get_from_secretstore_or_env("TAVILY_API_KEY")
            FUNCTION_NAMES.append("tavily_ai_search", "web_search")
          except Exception as e:
            TAVILY_API_KEY = None

          def extract_search_params(action_group, function, parameters):
          
              search_query = next(
                  (param["value"] for param in parameters if param["name"] == "search_query"),
                  None,
              )

              target_website = next(
                  (param["value"] for param in parameters if param["name"] == "target_website"),
                  None,
              )

              topic = next(
                  (param["value"] for param in parameters if param["name"] == "topic"),
                  None,
              )

              days = next(
                  (param["value"] for param in parameters if param["name"] == "days"),
                  None,
              )

              logger.debug(f"extract_search_params: {search_query=} {target_website=} {topic=} {days=}")

              return search_query, target_website, topic, days


          def google_search(search_query: str, target_website: str = "") -> str:
              query = search_query
              if target_website:
                  query += f" site:{target_website}"

              conn = http.client.HTTPSConnection("google.serper.dev")
              payload = json.dumps({"q": query})
              headers = {"X-API-KEY": SERPER_API_KEY, "Content-Type": "application/json"}

              search_type = "search"  # "news", "search",
              conn.request("POST", f"/{search_type}", payload, headers)
              res = conn.getresponse()
              data = res.read()

              return data.decode("utf-8")


          def tavily_ai_search(search_query: str, target_website: str = "",
                              topic: str=None, days: int=None) -> str:
              logger.info(f"executing Tavily AI search with {search_query=}")

              base_url = "https://api.tavily.com/search"
              headers = {"Content-Type": "application/json", "Accept": "application/json"}
              payload = {
                  "api_key": TAVILY_API_KEY,
                  "query": search_query,
                  "search_depth": "advanced",
                  "include_images": False,
                  "include_answer": False,
                  "include_raw_content": False,
                  "max_results": 3,
                  "topic": "general" if topic is None else topic,
                  "days": 30 if days is None else days,
                  "include_domains": [target_website] if target_website else [],
                  "exclude_domains": [],
              }

              data = json.dumps(payload).encode("utf-8")
              request = urllib.request.Request(base_url, data=data, headers=headers)  # nosec: B310 fixed url we want to open

              try:
                  response = urllib.request.urlopen(request)  # nosec: B310 fixed url we want to open
                  response_data: str = response.read().decode("utf-8")
                  logger.debug(f"response from Tavily AI search {response_data=}")
                  return response_data
              except urllib.error.HTTPError as e:
                  logger.error(f"failed to retrieve search results from Tavily AI Search, error: {e.code}")

              return ""


          def lambda_handler(event, _):  # type: ignore
              print(event)
              logging.debug(f"lambda_handler, event={event}")

              action_group = event["actionGroup"]
              function = event["function"]
              parameters = event.get("parameters", [])

              logger.info(f"lambda_handler: {action_group=} {function=}")

              if function not in FUNCTION_NAMES:
                  raise

              search_query, target_website, topic, days = extract_search_params(action_group, function, parameters)

              search_results: str = ""
              if function in ["tavily-ai-search", "web_search"]:
                  search_results = tavily_ai_search(search_query, target_website, topic, days)
              elif function == "google-search":
                  search_results = google_search(search_query, target_website)

              logger.debug(f"query results {search_results=}")

              # Prepare the response
              function_response_body = {"TEXT": {"body": f"Here are the top search results for the query '{search_query}': {search_results} "}}

              action_response = {
                  "actionGroup": action_group,
                  "function": function,
                  "functionResponse": {"responseBody": function_response_body},
              }

              response = {"response": action_response, "messageVersion": event["messageVersion"]}

              logger.debug(f"lambda_handler: {response=}")

              return response
  
  AgentLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: GetSecretsManagerSecret
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  - !Sub arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:SERPER_API_KEY-*
                  - !Sub arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:TAVILY_API_KEY-*

  AgentAliasLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt AgentLambdaFunction.Arn
      Principal: bedrock.amazonaws.com
      SourceAccount: !Ref AWS::AccountId
      SourceArn: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent-alias/*

  AgentLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt AgentLambdaFunction.Arn
      Principal: bedrock.amazonaws.com
      SourceAccount: !Ref AWS::AccountId
      SourceArn: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*

Outputs:
  WebScrapeLambdaFunction:
    Value: !Ref AgentLambdaFunction